import puppeteer from 'puppeteer';


class Runner {
  /**
  * The browser instance from puppeteer or null, if the browser instance
  * has not been launched yet.
  *
  * @property
  * 
  * @type {puppeteer.Browser|null}
  *
  */
  browser = null;
  
  /**
  * The map of steps you will use to run the puppeteer commands.
  * 
  * @property
  *
  * @type {Map<string, string[]>}
  *
  */
  steps = new Map();
  
  /**
  * Creates a puppeteer runner instance. This is mainly used in the scrappers namespace.
  * Allows for multiple pages to be run on one puppeteer browser instance with
  * dynamic steps, and properties.
  *
  *
  * @constructor
  * 
  * @param {object[]<string[]>} steps An array of objects that either contain a string or an
  * array of strings. The key will always be the `page` method you want to send to the puppeteer
  * browser.page instance.
  *
  * @param {Object<string>} props The dynamic properties you want to give the runner instance. This
  * is done so we do not store any kinds of passwords hardcoded or in a `process.env` variables.
  *
  * @returns {void}
  *
  * @example
  * import { Runner } from '@movement-mortgage/web-scrappers';
  * 
  * const jsonSteps = require('./steps.json');
  * const steps = jsonSteps.steps;
  *
  * var props = {
  *  username: 'test',
  *  password: 'got-this-from-storage-or-process-env',
  *  pageName: 'login-page',
  *  otherInput: 'maybe for a search'
  * };
  *
  * // show the chrome browser
  * props['headless'] = false;
  *
  * const runner = new Runner(steps, props);
  *
  * // a browser window will appear, when the tast is complete it will close.
  *
  */
  constructor([ ...steps ], { ...props }, { headless=false }) {
    // If there are no properties, then do not add them
    // to this instance.
    if ((Object.keys(props)).length > 0) {
      // create an interable from the object
      // props
      let entries = Object.entries(props);

      for (let [ key, value ] of entries) {

        // Only strings allowed to be properties
        
        if (typeof value === 'string') {
          this[key] = value;
        } 
      }
    }
    this.#setSteps(steps);

    let options = { headless }

    this.#openBrowser(options);
    
  }

  /**
  * Launch a new puppeteer browser instance, and begin the run sequence. 
  * @see {Runner~run}, for further details.
  * 
  * @private
  * @property
  *
  * @param {Object} options The launch options for puppeteer.
  *
  * @returns {Promise<void>}
  *
  */
  async #openBrowser(options) {
    if (!this.browser) {
      this.browser = await puppeteer.launch(options);
      this.#run();
    }
  }


  /**
  * Close the puppeteer browser instance, this can be done
  * if a critical error is thrown or if you just do not want to
  * keep the browser instance running. Mainly used at the end of the
  * run method.
  *
  * @property
  *
  * @returns {Promise<void|null>}
  */
  async close() {
    if (this.browser) {
      return await this.browser.close();
    } 
  }


  #setSteps(steps=[]) {
    for (let i in steps) {
      let entry = Object.entries(steps[i]);
      let k;
      let v;
      for (let [ key, value ] of entry) {
        if (this.steps.has(key)) {
          k = `${key}:${i}`;
          
        } else {
          k = key;
        }
        if (Array.isArray(value)) {
          v = value.map(item => {
            if (this.hasOwnProperty(item.toLowerCase())) {
              return `${this[`${item.toLowerCase()}`]}`;
            } else {
              return `${item}`;
            }
          });
        } else if (typeof value === 'string') {
          v = [ `${value}` ];
        }
        if (k && v) {
          this.steps.set(k, v);
        }
        
      }
    }
  }

  /**
  * Creates a new browser page, then runs through the steps
  * given on the `steps` property. Since this is a dynamic
  * runner, we want to make it as universal as possible, and
  * allow for the steps to be generated by a given storage class.
  *
  * @private
  * @property
  *
  * @returns {Promise<Runner~close>}
  *
  */
  async #run() {
    const page = await this.browser.newPage();
    // Iterate through the steps map
    for (let [ key, value ] of this.steps.entries()) {
      try {
        // run the page function, and take off the unique
        // key from the map.
        await page[key.replace(/:[0-9]+$/, '')](...value);
      } catch (e) {} 
    }
    // close the browser when all steps are completed.
    return await this.close();
  }
};
/** @exports {Runner} */
export default Runner;